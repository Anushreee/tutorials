6. Interfaces

interface Profile {
name:string,
age: number
}

let profile: Profile = {
name:'ratna',
age:2
}
s
By default properties of interface are mandatory. If i remove 'age' property, typescript will warn me that age is
missing.

we can make age optional.

interface Profile {
name:string,
age?:number
}

Also we can change profile on fly.

profile.name = 'Jim';

if we would like to forbid developers to modify the object we should use the readonly keyword. and this should go infront of the property name.

interface Profile {
readonly name:string,
age?: number
}

now we cannot modify the name.

In js it is very common to create an object and add properties on the fly, like this.

const a: any = {};

a.x =1;
a.y=2;

inorder to do properly in typescript, we should use the index signature to describe it.

lets create an interface A and create an index signature. in the square brackets, we specify the type of the key. it can be either string or number. then goes the colon.
and we define the type of the value. in our case it is the number.

interface A {
[key: string]: number
}

Now we can use this interface to describe this object.

So index signature allows us to describe dynamic properties. If the interface has a specific property, like someProp, the type of the value of this property should match
the type of the value of the index signature.
if it doesnt match, typescript will produce an error.

interface A {
someProp: string,
[key:string]:number| string
}

Error:"Property someProp of type 'string' is not assignable to string index type number". to make someProp a string we could use the union type for the index signature like this. So the index signature takes either number or string.

const a: A = {
someProp:'some prop'
}
a.x = 1;
a.y = 2;

We can also use interfaces to describe functions

For this we should add a call signature to an interface. Lets describe a function called "sum"- it takes 2 numbers and sums it up. So to describe a call signature we simply describe a function that takes 2 numbers, "a" and "b" and retuns the number- the sum.

interface Sum {
(a:number,b:number):number
}

Now lets create a function of this type.

const sum: Sum = (a,b)=>{
return a+b
}

and we should continue to grab the properties of the interfaces as usual.

We can also extend interfaces:

lets say we have an interface Parent. that has one property 'x' of type string and we have a child interface that extends the parent.

interface Parent {
x:string;
}

interface Child extends Parent {
}

Now the child interface inherits property 'x' from the parent. we need to define the property x that exists on the parent.

let child: Child = {
x:'dfsdfsd'
}

Also, we can extend multiple interfaces using a comma.

interface Parent2 {
y: string
}

interface Parent3 {
z: string
}

interface Child extends Parent, Parent2, Parent3 {
x:'sdfdf',
y:'sdfdsf',
z:'sdfdf'
}

7. Functions

function sum(a,b){
return a+b
}

We have a function called sum which takes two arguments a and b which are numbers and returns the sum. Lets make this function typesafe.
typescript allows us to specify the types of the function arguments and its return value. so "a" is a number. "b" is a
number. and the function returns a number.

function sum(a:number,b:number):number {

}

these are the basics to make the function typesafe.

we can also make a function type like this:

it is a function that takes two arguments a and b.  
 type MyFunc = (a: number, b: number)=> number.

this time we specify an arrow to specify the return type instead of a colon. Lets use this type to create a function.

now we can only assign a function that matches this signature to this variable. so we asssign an anonymous function that takes a and
b and returns their sum

const sum2: myFunc = (a,b)=>a+b;

this time we didnt need to specify any types. because typescript infers this type from the type signature.

By default, all arguments of a function are required. so if i call the sum without arguments, i will get an error saying that
it expects 2 arguments but got 0.

sum();

so lets give it these arguments.

sum(1,1);

we can make an argument optional. to do this, we should add a question question mark after the argument name.

function sum(a:number, b?:number):number {
return a+ (b);
}

now we will get an error saying that b is undefined. so we need to handle this case, so if b is provided, we use b. otherwise we use
b||0

function sum(a:number,b:number):number {
return a + (b||0);
}

and now we can remove this second argument.

sum(1);

we can also specify the default values for the arguments like this.

function sum(a:number, b:number =0):number {}

But we cannot use both the default value and the optional value like this:

function sum(a:number, b?:number =0):number {} //we cannot do this.

so lets remove the question mark. this is because when we specify the default value, the argument becomes optional. so lets remove
this check.

quite frequently we create functions that take unknown number of arguments.

we have a function calle sumEverything. it takes a lis of numbers and we use rest operator to gather all the numbers into an
array of numbers, and then, we call the reduce method on this array to sum these numbers up.

function sum(...numbers){
return numbers.reduce((result,num)=>result+num,0);
}

document.write(sum(2,3,4,4));

Class

We have a simple class called "Robot", and, this class has four members: the "name" property,
the constructor;
This method is being called when we instantiate the class using the "new" keyword. In here we set up the
property "name". The "askName" method which logs the Robot's name. And, the "move" method that moves the Robot
by some distance. Later we instantiate the class using the "new" keyword,
then, the class name, and in the parenthesis, we list the constructor arguments. And, we have only one argument,
the "name", and then, we call the askName method which outputs:
"My name is John". One class can inherit properties of another class.

class Robot {
name: string;

    constructor(name:string){
        this.name = name;
    }

    askName(){
        console.log(`${this.name}`);
    }

    move(distance:number) {
        console.log(`${distance}`);
    }

}

const myRobot = new Robot('Laila');
const robot = new Robot('tony');
robot.askName();

Let's create a subclass of Robot and call it Flying Robot.

This class extends

Robot.

class FlyingRobot extends Robot {
constructor() {

    }

}

We use the "extends" keyword. And now, FlyingRobot inherits the properties and methods of the Robot class.

We can override members in the child class. Let's override the constructor.

Our constructor takes the "name" argument. First, we have to call the constructor of the parent class. We

use the function called "super" for this.

class FlyingRobot extends Robot {
constructor(name:string) {
super(name);
}
}

So, "super" refers to the constructor of the parent class and we give it the name property. Then, because

this robot is flying, I suppose it has a jetpack.

class FlyingRobot extends Robot {
jetpackSize: number;
constructor(name:string) {
super(name);
}
}

So, let's add another property and call it jetpack

Size. It's a number. Let's set up this property in our child constructor.

class FlyingRobot extends Robot {
    jetpackSize: number;
    constructor(name:string, jetpackSize:number) {
        super(name);
        this.jetpackSize = jetpackSize;
    }

    move(distance: number) {
    	console.log(`${this.name} is flying`);
        super.move(distance);
    }

    

}

class robot = new Robot('John');
robot.askName();

Now let's override the method "move".

Let's make sure that the robot is flying.

And now, let's call the "move" method from the parent.

We use "super" to refer to the parent class and call "move".

Now, let's create the FlyingRobot

instance.

The FlyingRobot constructor takes two arguments: the name and the jetpackSize.

const flyingRobot = new FlyingRobot('Jim',2);

Now, let's call the "move" method to make sure we have overridden it.

flyingRobot.move(10);

We move the robot by 10. And, we have "Jim is flying" from here and the "Jim moved 10 meters", from the parent

class.

class Robot {
    name:string; //this name here refers to the properties of the class

    constructor(name:string){ //name here refers to the arguments passed to the constructor.
        this.name=name; //this.name refers to the property of the class. 
    }
    askName(){
        console.log(`${this.name}`);
    }
    move(distance:number){
        console.log(`${this.name} moved ${distance} meters`);
    }
}

class FlyingRobot extends Robot {
    jetpackSize:number;

    constructor(name:string,jetpackSize:number){
        super(name);
        this.jetpackSize=jetpackSize;
    }

    move(distance:number){
        console.log(`${this.name} is flying`);
        super.move(distance);
    }
}
const myRobot = new Robot('sdfsdf');
myRobot.askName();
myRobot.move(30);

const flyingRobot = new FlyingRobot('Jim',2);
flyingRobot.move(81);


We can control the scope of class members using modifiers. There are 3 modifiers:

public, private, and protected. When we don't specify a modifier, a member becomes public like the jetpack

Size property.

This means that the class consumer can access this property on the class instance, like this.

console.log(flyingRobot.jetpackSize);

And here we go.

The flyingRobot's jetpack size is 2.

So, we have full access to this property. To set a modifier, we type the modifier's name in front of

the property, like this. Let's try to set it to private.

class FlyingRobot extends Robot {
public jetpackSize: number
}

Private means that this property can be accessed from the class where it has been declared. Only from the

FlyingRobot class, like this.

class FlyingRobot extends Robot {
private jetpackSize: number
}

console.log(flyingRobot.jetpackSize);

We get an error, like here.

Property jetpackSize is private.

Now, let's see how protected modifier works.

Let's set the name of the Robot class to "protected". When a member is protected, it can be accessed only

from the class where it has been defined or from any subclass, like FlyingRobot

in this case. And, the consumer of the class won't be able to access it from the outside. So, we can access

the "name" property in here or in here, but not outside of the class.

In here we cannot access it.

We will get a notice that it is protected. Like interface properties,

class properties can be readonly. To make a property

readonly, we add the readonly keyword in front of the property name, like this.

Now, once the jetpackSize property is set in the constructor, we won't be able to change it in any other

method, like this. And, we get an error that the jetpackSize is a readonly property. Also,

instead of defining properties in here, we can define properties in the constructor parenthesis to make

the whole class structure a little simpler

if we don't have a lot of properties. So, let's simplify this.

Now, let's remove the protected name

property and describe it in the constructor.

And, now we don't need to assign the argument name to the property "name" because TypeScript does it for

us. We can use getters and setters to process a property while it's being written or read.

Let's create a getter and a setter for the "name" property.

Let's start with the setter. To create a setter, we type the "set" keyword.

Then, the name of the property.

And, this is a method that takes the value of the property.

In this case the name is a string and this method should set the value of the property.

Also, we cannot name our setters and getters the same as we named the property.

WE CANNOT NAME OUR SETTERS AND GETTERS THE SAME AS WE NAMED THE PROPERTY. SO LETS RENAME THE PROPERTY. LETS ADD UNDERSCORE IN FRONT OF THE NAME.

So let's rename the property.

Let's add underscore in front of the name.

And now we can set it, like this.

"this" "underscore" "name" is equal to value.

And, here we can override it as we like.

Let's add a prefix for the demonstration.

Now, let's create a getter for the name. We type the keyword "get", then, the name of the property.

And, this is a method that returns the property's value.

In this case we return the name property. And, in here,

let's also, overwrite it a little.

Let's add a suffix.

Now, let's update the name of the flying robot just to see how it works.

Now, let's log this.

And, here we go.

"My name is PREFIX_Kevin_SUFFIX". Let's talk about static members. Let's create a property called "color" and

let's create a setter for this color.

And, in the setter I would like to check if this color is available and if it's not available we will

throw an error.

So let's create a setter.

we cannot use the same name for the setter as we use for the color property. So, let's add an underscore

in front of the color property. And, in the setter we set the color.

Let's create a static property called availableColors

and for the availableColors we have only two colors: green and yellow.

Also, let's create a static member that will use this property to check if the color is available.

Let's name it isColorAvailable.

And, this is a method that takes a color and returns a boolean.

We take the Robot.availableColors and check if it includes the color.

Now, let's use this method in the color setter. If Robot.isColorAvailable, color, ..., oh, it

should be "not", if color is not available, we throw an error:

Color

"color" is not available. As you might have noticed, we cannot access static properties or methods on the

class instance. So, we cannot do this:

this isAvailableColors.

There is no such method on this instance.

We can only access static properties on the class itself, like this, Robot

dot, is available, is color available or available colors. You can also use modifiers with static members.

By default,

When we don't specify a modifier, they are public, so we can access them from the outside of a class,

like here, Robot is color available.

Or Robot available colors. If we make this property private, (we do it like this: private static available

colors),

this property becomes unavailable from the outside of the class.

Like here, we see the message that the availableColors property is private. And, one important thing, that

we have to note is that classes have two sides: the "static side" that includes the static methods and properties

and the constructor. And, the "instance side" that includes the instance methods and properties, like color,

askName, name, and other instance methods.

Video course
Teach the world online
Create an online video course, reach students across the globe, and earn money
Udemy
Copyright © 2019 Udemy, Inc.
Terms Privacy Policy and Cookie Policy Help and Support

×Close alert


Classes Quiz

A private member can be accessed only from the class where it is declared and we cannot access it from the class instance (e.g. new SomeClass().somePrivateMember)
A protected member can be accessed from both the class where it is declared and any subclass. And you cannot access this member publicly (e.g. new SomeClass().someProtectedMember).

We have the following code:

class Person {
    constructor(
        name: string,
        protected email: string,
        private salary: number
    ) {}
}
 
class Employee extends Person {
    getEmployeeInfo() {
        return `${this.name} ${this.email} ${this.salary}`
    }
}
 
const jack = new Employee('Jack', 'jack@example.com', 1000)
console.log(jack.getEmployeeInfo())
What will the console.log output?

jack jack@example.com

The salary property is private in the parent class, so we can't access it from the child.

What is the correct way to create the setter and getter for the property amount?

class A {
    amount: number;
}


Class By Maxmiller

Creating classes and Class Properties:

So let's create a class,

we do this with the class keyword and then we can pick whatever name we want,

let's say person.

This will give us a person class

class Person {
    
}

and if you are familiar with ES6 features, so far that's the same way how you create a class in ES6

and for this module of course, it really helps to know about object-oriented programming

and if you already know some other languages which use classes. I'm not going to dive super deep into

explaining what classes are and what you use them for,

basically they allow you to prepare some kind of blueprints for objects, so you can later on create objects

based on a class to then make sure that this object already has some properties or methods which again

you define in this class we're setting up here

but if that is all new to you, definitely check out some tutorials on object-oriented programming and

classes in general

and it probably is a good idea to also have a look at ES6 classes.

So enough of talking. I'm creating a class here to create such a blueprint and I could give this class

a property, name for example, which should be of type string and that already is one important difference

to ES6 classes.

class Person {
    name:string
}

You create properties just like that in TypeScript,

you don't have to set them up with the this keyword in the constructor of a class,

you assign them directly in the class body

as you might know it from other languages, like again C# or Java. You could prefix or prepend this

name property here with a public keyword and that would make this property available to

whoever wants to access it but I can leave it out since the default is public,

class Person {
    public name:string;
    private type:string;


}

so this property will be public which means accessible from outside.

So I created the property on this class and I can add another one, let's say type but let's say that

I want type to be a private property, which means you can only access it from inside of this class

or later on whichever object you create

based on this class. So you can't set or read it from outside of this

and that also is a major addition because Javascript, no matter if we're talking about ES5 or ES6, doesn't

offer this kind of support or these kinds of properties,

it doesn't know private and public properties, everything is public there and you have to use some kind

of hacks or workarounds to create kind of private properties.

So here in TypeScript, I create a private property type like this and I assign a type of string to this

property.

I can also create a protected property

and what's different because protected and private? Private properties are only available or accessible

from the object you base or you create based on this person class,

so only within this object. Protected properties

also meet this definition

but additionally, they're also accessible from any objects or classes which inherit from this class.

So if we were to inherit from this person class and I will come back to inheritance later on, then

the child class which inherited from person would also have access to a protected property but not

to a private one,

so let's say we have the protected property age which should be a number here.

class Person {
    public name:string;
    private type:string;
    protected age:number;

}



 That was quite a lot of

talk about properties but it is important to understand how you can modify them to make them available

only inside or outside of this class and it is important to understand that you set them up directly

in the class body and not in the constructor.

IT IS IMPORTANT TO UNDERSTAND THAT YOU SET THEM UP DIRECTLY IN THE CLASS BODY AND NOT IN THE CONSTRUCTOR.


That being said, you can provide a constructor function which may take some arguments, like name and which

then allows you to assign this name to the name property,

class Person {
    name:string;
    private type:string;
    protected age: number;

    constructor(name:string) { // this name refers to the argument passed to the constructor.
        this.name = name;
    }
}

so this name here:
    public name:string;

 refers to the property of this class, whereas this name refers to the argument passed

to the constructor. As a side note,

there is a quick shortcut TypeScript offers you for setting up a property which you also want to

set in the constructor.

Imagine we have something like a username, so we have this name and we also have a username,

then we could also say public username of type string.

class Person {
    name:string;
    private type:string;
    protected age: string;

    constructor(name:string, public username:string){
        this.name = name;
    }
}

Notice the public keyword here,

with that I'm telling TypeScript not only expect to get a username argument in the constructor function

but also automatically create a public property in this person class

and this could be private or protected too and assign the argument you get passed into the constructor

to this property.

So this expression here basically is a shortcut for creating a property up here, getting the argument

and then assigning the argument, put it in other words,

I could also write public name, rid of this, get rid of this and it will still work the same

but I will leave this kind of mixed set up to have a good example of both possible ways of creating

and assigning properties. Now before going more into detail,

let's use this class and I do use a class by instantiating it, which means I create an object based on

this class. I will store this object, make it a const, in this person constant here and I instantiate it

with the new keyword,

so I create a new person like this, new person.

Now of course the person here expects to get two arguments since the constructor expects to get two

arguments, as we call the constructor with this new person call here.

So I pass Max as my name and the username might be max with a lower case M,

very very creative here, I know.

const person = new Person('Max','max');

console.log(person);

So I created my person and I can then log this person to the console and I will save this and then

let's have a look at the console. You see my person here, it is of type person as you can see, it has the

username max with a lowercase m and the real name is Max with an uppercase M.

Person {username: "shree", name: "shreela"}

So as you can see, this uses the constructor function, it is able to assign the username here with

this shorter setup syntax ie. public username:string as well as the name with the longer setup syntax here

and to prove this, I can also access name and username like this.

console.log(person.name,person.age);

Notice that my IDE doesn't offer me type or age because both are private or protected, which means not

accessible from outside,

I can only use them inside of this person object,

I can't access them from outside like I'm doing with name or username. If I save

this, I see Max and max here because I access the name and the username

and this again proves that this shorter syntax here works too.


58. Class Methods and Access Modifiers

I already said that I can't access type and age from outside but what sense does this make to set up

properties like this then?

Well let's add a method to this person class because we can add methods too and let's say we have one

which is called printAge and this is how we set up a method, like a function without the function keyword

and printAge

should simply give me this age.

class Person {
    name: string;
    private type:string;
    protected age: number;

    constructor(name:string,public username:string) {
        this.name = name;
    }

    printAge(){
        console.log(this.age);
    }
}

Now here, I can access age because I'm inside of this class or later on, inside of this object and private

means accessible from inside,

so I have no problem with accessing it. If I also want to set a protected or private property from outside,

I could create the setType method, of course

the name is up to you, pass a type which should be a string since the type property also is a string and

then set this type equal to type,

I can thereafter print this type to see that this worked. With these changes in place, I can call person

printAge and I can call console log person or no, I don't have to console log, I can just call person setType

cool guy because that's what I am.


class Person {
    name: string;
    private type:string;
    protected age: number;

    constructor(name:string,public username:string) {
        this.name = name;
    }

    printAge(){
        console.log(this.age);
    }

    setType(type:string){
        this.type = type;
        console.log(this.type);
    }

  
}

const person = new Person("Max","max");
console.log(person.name, person.username);

person.printAge();

person.setType('Cool Guy');


So printAge and of course we would see undefined since age isn't set up, so I can initialize it up there,

that also works.

I can initialize properties right after or right when declaring them here,

I don't have to initialize them through the constructor,

I can do it up here

too. With that if I save this, it gets compiled automatically while you still see Max max, then you see my age,

so the initialization worked as did the try to access a private property inside of this class or object

and you see that setType also worked

since I see cool guy here and I printed this type after assigning it here in the setType method.

So this is how you initialize properties right

when declaring them, how you create methods which you may access from outside and how you can access

private properties inside your person class.

Now one important thing to know is that methods can also be private or protected

which serves the same purpose as private and protected properties serve.

You can't access them from outside but you can use them inside of your class.

So if you set setType to private for example, well then we could say that we want to access it whenever

we print the age and we want to set it to old guy.

class Person {
    name: string;
    private type:string;
    protected age: number =27;

    constructor(name:string, public username:string){
        this.name=name;
    }

    printAge() {
        console.log(this.age);
        this.setType('Old Guy');
    }

    private setType(type:string){
        this.type=type;
        console.log(this.type);
    }


}

const person = new Person('anushree','anu');
console.log(person.name);
console.log(person.username);
//person.setType("cool guy"); //commented out because it wont work with a private method. 

person.printAge();


 With that,

I of course have to remove or comment out this line here cause it won't work with private method and

if I save this, we now see Max max 27 and then old guy because I'm setting a type of old guy here and

I call this setType whenever I print the age. Also important, you have to use this if you want to access properties

or methods of an object when you are inside of it, like here in the constructor

constructor(name:string, public username:string){
        this.name=name;
    }


 or here when we print the age or

  private setType(type:string){
        this.type=type;
        console.log(this.type);
    }


here when we assign the type or here when we print the age.

 printAge() {
        console.log(this.age);
        this.setType('Old Guy');
    }

That was a lot of talking about this relatively simple yet complex class keyword and how to create and

use classes. As you saw,

it really makes creating such blueprints of which you can create new object simple and with the

private and protected modifiers

here, you get powerful ways of controlling who is able to access your properties and methods in a class.

Another very important concept added with ES6 as well as with TypeScript is that your classes can also

inherit from each other, so you may extend classes and implement inheritance.

How?

Well, let's have a look.

59. Inheritance


So let's have a look at inheritance next. Let's say I have my person class and I want to create a specific

Max class of this person, just because well I like my name so much. So I create a class, Max

and you probably should read one matching your first name or whatever you like

and I want to use this person class,

I just want to fine tune it a little bit.

I want to have the printAge and the setType

method, I want to have all these properties but I want name to be Max by default.

Now rewriting this whole class would be not what I want because well I duplicate all the code and it

makes my code less reusable and so on,

so instead I extend the person class with extends keyword, I extend person, like this.

class Max extends Person {
    name = "Max"
}

What this means is take this person class, use all of the code inside of it and now whatever I specify

in here gets either appended

if it isn't included in the person class or overwritten if it was included.

So if I were to say name should be equal to Max, then this will overwrite the name property in my person

class, which means that if I now create a new person or a new Max to be precise, a new Max, like this

and I print Max,

well then you see I would get an error because the constructor here still expects two arguments because

I'm still using this constructor. Again

Max, this class has all the content of the person class plus or overwritten, whatever I define here.

So I still have to use the constructor,

so let's actually see what happens if I pass

Anna here as a name and then lowercase max as a username,

let's see what happens.

You see the name is still Max, even though I passed Anna to the constructor which sets this name equal

to

Anna in this case, it gets overwritten by this property definition here in the Max class.

So the content defined in the main class here always overwrites the content of your superclass, of your

parent class,

so it doesn't matter that I pass Anna here. Nonetheless, I might have solved this issue by adding a constructor

here and I will come back to constructors in the next lecture.


Getters and Setters:

Another cool feature you might know from other languages are getters and setters and vanilla

Javascript also has some ways to create getters and setters but TypeScript makes it really easy. I'll

create a new class for this,

it won't inherit from any class, it's a normal class here and I'll set up a private property called

_species which should be of type string.

Now generally, you shouldn't prefix your private properties with an underscore,

that's the style guide for TypeScript

but in this case I'll make an exception and you'll see why in a second because I don't want to be able

to access this species property from outside

but I want to offer a controlled access, which means through a getter or a setter which allow me to execute

some code before actually returning or setting the value.

I WANT TO OFFER A CONTROLLED ACCESS THROUGH GETTERS AND SETTERS WHICH ALLOWS MET TO EXECUTE SOME CODE BEFORE ACTUALLY RETURNING OR SETTING A VALUE.

So let's say whenever I try to set this value, I want to check if the string provided is longer than,

let's say at least three characters,

so I don't want to set species to anything which has only three characters or less.

So I can create a setter for that which allows me to execute some code whenever I try to set a value

and I do it with the set keyword and then species.

Now this name is up to you but this will be the property name accessible from outside later on.

I do add parentheses here but I will not call it like a method from outside,

that's important to understand,

I will call it like a property but I set it up like a method because again, I can execute some code

here, like a method which gets called. It will actually also get a parameter of type string and TypeScript

will pass this parameter for me kind of. In the end, it will be Javascript code which looks differently

anyways but you can think of this value being passed to this kind of only theoretically existent method

here automatically.

So again, I will and you will see this, only call this like a property

but behind the scenes it will give me the value I want to assign as an argument to this method that

it will execute automatically.

So here, I then want to check if the length of value is greater than 3, if that is the case,

I want to assign this species to this value, otherwise I will assign this species to default, something

like that

and I can also set it to this value up here, default value.

So that is why I have this underscore because I want to use this species name and therefore, I have

to make sure we have a different name for my private property.

Now that allows me to set it

but I also want to be able to read it.

For this, I'll set up a getter, so I'll use the get keyword with species here, again like method here

but with this time without an argument and then here, I decide what I want to return.

I do have to return something because I try to get something in the end but I could also return hello

and then I would always see hello when I try to access species, that would work fine but I can also return

this species or transform it before showing it, whatever I want to do. With that,

I set up some getters and setters and then I can create a new plant based on that and I can first log

plant.species, notice how I act species without the underscore, that refers to this

species property here which is called like a property, not like a function.

If I save this, it gets compiled and we see default here, which makes sense because we have default

as a default value. Next, if I try to set species to let's say AB,

so only two characters and then I log plant.species again,

well let's see what we now see in the console.

Well we see default twice,

so the first default here of course stems from this console log but the second default comes from this

console log.

So species wasn't set to AB because it didn't make it through this validation here,

therefore we set it to default and we did not set the value.

Now if I copy that code and set species to green plant and I save this,

well let's have a look at the console now,

now we see green plant being printed because it makes it through this check here

and therefore we assigned this species the new value which would be green plant in this case.

So that is a convenient way to use getters and setters to control access to your properties and make

sure that certain criteria are met before assigning a value or returning a value.

THAT IS A CONVENIENT WAY TO USE GETTERS AND SETTERS TO CONTROL ACCESS TO YOUR PROPERTIES AND MAKE SURE THAT CERTAIN CRITERIA ARE MET BEFORE ASSINING A VALUE OR RETURNING A VALUE.


Video course
Teach the world online
Create an online video course, reach students across the globe, and earn money
 Udemy
Copyright © 2019 Udemy, Inc.
Terms  Privacy Policy and Cookie Policy  Help and Support

×Close alert








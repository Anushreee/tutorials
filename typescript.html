6. Interfaces

interface Profile {
    name:string,
    age: number
}

let profile: Profile = {
    name:'ratna',
    age:2
}
s
By default properties of interface are mandatory. If i remove 'age' property, typescript will warn me that age is 
missing. 

we can make age optional.

interface Profile {
	name:string,
	age?:number
}

Also we can change profile on fly.

profile.name = 'Jim';

if we would like to forbid developers to modify the object we should use the readonly keyword. and this should go infront of the property name. 

interface Profile {
    readonly name:string,
    age?: number
}

now we cannot modify the name.

In js it is very common to create an object and add properties on the fly, like this.

const a: any = {};

a.x =1;
a.y=2;

inorder to do properly in typescript, we should use the index signature to describe it. 

lets create an interface A and create an index signature. in the square brackets, we specify the type of the key. it can be either string or number. then goes the colon.
and we define the type of the value. in our case it is the number. 

interface A {
	[key: string]: number
}

Now we can use this interface to describe this object. 

So index signature allows us to describe dynamic properties. If the interface has a specific property, like someProp, the type of the value of this property should match
the type of the value of the index signature.
if it doesnt match, typescript will produce an error.

interface A {
	someProp: string,
	[key:string]:number| string
}

Error:"Property someProp of type 'string' is not assignable to string index type number". to make someProp a string we could use the union type for the index signature like this. So the index signature takes either number or string.


const a: A = {
	someProp:'some prop'
}
a.x = 1;
a.y = 2;

We can also use interfaces to describe functions

For this we should add a call signature to an interface. Lets describe a function called "sum"- it takes 2 numbers and sums it up. So to describe a call signature we simply describe a function that takes 2 numbers, "a" and "b" and retuns the number- the sum.

interface Sum {
	(a:number,b:number):number
}

Now lets create a function of this type.

const sum: Sum = (a,b)=>{
	return a+b
}

and we should continue to grab the properties of the interfaces as usual. 

We can also extend interfaces:

lets say we have an interface Parent. that has one property 'x' of type string and we have a child interface that extends the parent. 

interface Parent {
	x:string;
}

interface Child extends Parent {
	
}

Now the child interface inherits property 'x' from the parent.  we need to define the property x that exists on the parent. 


let child: Child = {
    x:'dfsdfsd'
}

Also, we can extend multiple interfaces using a comma. 

interface Parent2 {
	y: string
}

interface Parent3 {
	z: string
}

interface Child extends Parent, Parent2, Parent3 {
	x:'sdfdf',
	y:'sdfdsf',
	z:'sdfdf'
}

7. Functions

function sum(a,b){
    return a+b
}

We have a function called sum which takes two arguments a and b which are numbers and returns the sum. Lets make this function typesafe.
typescript allows us to specify the types of the function arguments and its return value. so "a" is a number. "b" is a
number. and the function returns a number.

function sum(a:number,b:number):number {

}

these are the basics to make the function typesafe. 

we can also make a function type like this:

it is a function that takes two arguments a and b.   
 type MyFunc = (a: number, b: number)=> number.

 this time we specify an arrow to specify the return type instead of a colon. Lets use this type to create a function.

 now we can only assign a function that matches this signature to this variable. so we asssign an anonymous function that takes a and
 b and returns their sum

 const sum2: myFunc = (a,b)=>a+b;

 this time we didnt need to specify any types.  because typescript infers this type from the type signature. 

 By default, all arguments of a function are required. so if i call the sum without arguments, i will get an error saying that
 it expects 2 arguments but got 0.

 sum();

 so lets give it these arguments. 

 sum(1,1);
 
 we can make an argument optional. to do this, we should add a question question mark after the argument name.

 function sum(a:number, b?:number):number {
     return a+ (b);
 }

 now we will get an error saying that b is undefined. so we need to handle this case, so if b is provided, we use b. otherwise we use 
 b||0

 function sum(a:number,b:number):number {
     return a + (b||0);
 }


 and now we can remove this second argument.

 sum(1);

 we can also specify the default values for the arguments like this. 

 function sum(a:number, b:number =0):number {}

 But we cannot use both the default value and the optional value like this:

 function sum(a:number, b?:number =0):number {} //we cannot do this.

 so lets remove the question mark. this is because when we specify the default value, the argument becomes optional. so lets remove 
 this check. 
 
 quite frequently we create functions that take unknown number of arguments. 

 we have a function calle sumEverything. it takes a lis of numbers and we use rest operator to gather all the numbers into an 
 array of numbers, and then, we call the reduce method on this array to sum these numbers up. 

 function sum(...numbers){
    return numbers.reduce((result,num)=>result+num,0);
}
   
   document.write(sum(2,3,4,4));










































1. Splice method
2. Slice Method
3. JSON
4. For Of loop
5. For In Loop
6. JSON.stringify
7. Reduce Method
8. export default considered Harmful
9. Dot Notation vs Bracket Notation
10. Truthy 
11. 



https://www.youtube.com/watch?v=pNJDbE-d77w

1. Splice method I CD - (I stands for Index, C stands for Count and D stands for Delete)

Splice method helps to add or remove stuff from the middle of the array. 

var array = [1,2,3,4,5];

if you do this:
delete array[1];
here 1 in the bracket is the index of the array.

this will actually delete the 2 but will also leave undefined, so now the output right here will just have the empty space. 

[1, undefined, 3, 4, 5];

but array.splice(1,1);leades to

Now, splice has three parameters that can be called. only two are required. the first one, is the index in which you want to start at. and the second one is how many inputs in the array you want to delete. 

so in the first one, lets say we dont actually want to delete anything. but we want to add at that spot a new thing: Feb for instance. 


const months = ['Jan', 'March', 'April', 'June'];
months.splice(1, 0, 'Feb');
console.log(months);	
["Jan", "Feb", "March", "April", "June"]

so for that:

var array = [1,2,3,4,5];

array.splice(1,0,200)

here we are starting at index 1. 0 means we are not
going to delete anything because this is where you define how many numbers you are going to delete. 
now we want to add the number 200.
so the output is:
Â [1, 200, 2, 3, 4, 5];

now we are going to delete two numbers but we are not going to replace anything as well.

array.splice(1,2);
Now our array would have the numbers [1,4,5]; and their respective indices would be 0,1,2

Now lets delete two numbers and add two numbers starting at position 2.

starting at index 1, we are going to delete two number and then we will put the numbers 11 and 12. so,

array.splice(1,2,11,12)

there are two required parameters here. and from 3rd paramter it is optional. 

output: 1,11, 12, 4, 5, 6


Slice Method:

https://www.youtube.com/watch?v=QdwLGI1yNrk

Slice method will return a copy of the portion of an array into a new array depending on the start and the end of 
the index you supply to the slice method. also note that the end index will not be included. so, let me 

SI EI
let arr = [12,23,44,56,77,88,99,100];
let r = arr.slice(2,4);

arr.slice(2,4);
2 is the starting index and 4 is the ending index. so it will start at 44 and end at 77.

so it should copy 44 and 56 and place it into r. 

Now as i had noted earlier that end index is not included which is why 77 is not included in the subset you get from the slice. also, note that original array will not be affected by slice. 

if you dont specify the end index, then it will assume that you want to slice till the end of the array.So, in this case it will start at 44 and give you the numbers till the end. 

let arr = [12,23,44,56,77,88,99,100];
let r = arr.slice(2);
console.log(r);


also, if you do not supply any values, then it will copy from the beginning to the end of the array. so it will give you the entire array.

output: [44,56,77,88,99,100];
let arr = [12,23,44,56,77,88,99,100];
let r = arr.slice();
output: [12,23,44,56,77,88,99,100];


Difference between slice and splice

Although slice and splice sound very similar and confusing, they are very distinct. 

Slice:

Slice returns a portion of the array as a second array. so, really it is taking a sub array and it returns it as a second array.

Slice does not modify the array it is invoked on.  this is different from splice. splice modifies the array it is invoked on. 

First argument specifies the starting element. 0 marks the first element and so on. 

second argument specifies the ending argument. remember it doesnt remove them. it doesnt modify that array. it just takes those elements and creates a second array. 

second argument is optional. 

so this is our array:

let arr =[1,2,3,4,5,6];
and let me declare another variable where the subset of the array will be placed.  let me name it arr1.

now i am going to take the slice of the arr array. and i am going to begin with the first element. and i am going to extract up to 2. here the index number 2 will not be included.

let arr1 = arr.slice(0,2);

output arr1 = [1,2];

now let us check whether we modified the arr at all,

console.log(arr);
output: [1,2,3,4,5,6];

so it didnt modify the array that it is invoked on. 

Another example:

let arr2= arr.slice(2,3);

so it will start with the number 3 because it is on index 2. it will go up to but not include number 4. 
console.log(arr2);
output arr2:[3];

it doesnt mutate the original array at all.


Some people tend to avoid splice because splice will mutate the array. 

Now i had said that in slice, the second argument is optional.

so, 

let arr3 = arr.slice(4);

output: [5,6];

now the original array is not mutated.

So that is slice.


Now, lets take a look at splice. 
1 letter difference to slice. and that is why everyone mixes them up. 

Array.splice(start,delete);


JSON:

JSON stands for Javascript Object Notation. And, it is lightweight data-interchange format. it is used to send data back and forth to a server as text.

it is actually based on a subset of javascript: javascript object literals. 

Json is very easy to read and write.

json has replaced XML and it is often used with ajax.

it is ironic that ajax uses json more than xml. ajax is used to send data back and forth between client and server without having to refresh the page in the browser.  and later on i am going to show you how to make an ajax request too. 

code word for parse: opapa when meanse for object it is parse

json can also be parsed with any modern programming languages either natively or through libraries. 

now lets look at the different datatypes that can be used with Json. 

1. Number: no difference between integer and floats. 

if you use a numeric with no quotes around it, it will be looked as a number.

2. String: which is a string of unicode characters. these must be wrapped in double quotes.

3. Boolean: True or false

4. Array

5. Object: we can have multi tier objects embedded in the json object.

6. null: empty value. 

when working with object literals, we can use any standard data types including functions and dates. but if it is specified as json values need to fit into one of these.

and we do have supersets of json such as beeson which is used by mongo db that allow additional data types but thats beyond this course.



Rules that the syntax follows:

json works by using key value pairs:
{"name":"Brad"}

use double quotes for both the keys and values.

if it was a javascript object literal, we wouldnt need the quotes around the key, just the string value but if we wanted this to be parsed as json, as valid json then we need the double quotes around both the key and the value. 


if it's if it's valid json it also much must follow the specific data types that we just described.Now, if you
want you can create a file that is strictly for Json it must be valid and it has to have a .json file extension.
And then the mime type associated with Jason is application/json so if you are working with let's say a restful api that and you want to send Json you can use this type in the header. 

all right so let's take a look at a really simple json example.
{
	"name":"Bradly",
	"age":"35",
	"address": {
		"street": "5 main st",
	},
	"children": ["Brianna","Nicholas"]

}




Now lets go ahead and write some code:



var text = '{ "name":"John", "birth":"1986-12-14", "city":"New York"}';
//my assumption: parsing works only if it is in the same line.
var obj = JSON.parse(text);
  
console.log(obj);

{name: "John", birth: "1986-12-14", city: "New York"}


var person = {
	name : "Brad",
	age : 35,		
}

person = JSON.stringify(person);
console.log(person);

output: {"name":"Brad","age":35}





we're going to actually look at and write some code alright guys so I have an index.html file here that I just have in a folder called JSON sandbox and it just adds your basic HTML head and body tags and then we have this
script to these script tags in the body this is where we're going to write our JavaScript so it's really important to understand that a JavaScript object and a JSON object are a little different and we went over some of this in the slides and you saw that  with Json you have to have double quotes around both the key and the value.when you're working with standard JavaScript objects you usually don't but you can. so what
I'm going to do here is just create a variable called person and set that to an object which is represented with
curly braces and in here we're going to say name and we're going to set that to
a string called Brad.

<script>

	var person = {
		"name" : "Brad",
		"age" : 35,
		"email": function(){
			return 'brad@gmail.com'
		}
	}

	console.log(person.email());

</script>


console.log(person);


okay so this is
actually a JavaScript object this is not valid Json.

So what we can do here is we can access I'm just going to use
console.log you can use alert well actually you can't use alert because it's an object but what this will do is
just log to the console down here log out person all right so if we reload this you'll see that it gives us an object.

 And it  has the key value pair name and Brad now this works in JavaScript in fact this is what you would do but this is not valid Json if we go to jsonlint.com which is adjacent validator and we take actually let's just go ahead and put in here name Brad and we say validate Jason it's going to give us it's going to tell
us that this is not valid and the reason for that is because it doesn't have
double quotes around the key.

https://www.youtube.com/watch?v=wI1CWzNtE-M&t=89s


so if we go ahead and do that and click validate it says valid Json now we can in fact go over here and put double quotes like that and then if we go back and reload this is still going to work alright but
I'm going to leave those quotes off now when we log this out it's it's logging out the object if we want to access a certain property such as name which is the only property it has then we can just do dot name and if we reload we get Brad we can add on to this and let's say age 35 and then down here we can say
person dot age and that will give us 35
now.

When using JavaScript objects we can set the data type of the value to anything that we can do in JavaScript
even a function so if we wanted to say email and set that to a function and then just return say Brad at gmail.com
and then go down here and say person dot email which is a function so we need to
put in our parentheses reload and we get Brad at Gmail alright and this is certainly not valid Jason although it is a valid JavaScript object so if we go over here and we try to do that let's say email
email and we'll set that to function and
we'll return Brad at Gmail and we try
and run that of course that is not valid

<script>

	var person = {
		"name" : "Brad",
		"age" : 35,
		"email": function(){
			return 'brad@gmail.com'
		}
	}

	console.log(person.email());

</script>

all right it has to be one of the data
types that we specified in the slides
which is number string boolean null and
array and object okay.

 it has to be one
of those all right so I'm just going to
take this this email off right here.

<script>

	var person = {
		"name" : "Brad",
		"age" : 35,
		
	}

	person = JSON.stringify(person);
	console.log(person);

</script>


 this
function and I want to show you that we can prepare this as jason if we wanted to send it through Ajax to a server or do something that requires it to be valid Json okay.



 We can actually change it to adjacent string so to do that we can use a function called stringify so
what I'll do here is just say person
equals Jason dot stringify and then pass
in that person object 

person = JSON.stringify(person);
console.log(person);


and then down here
let's console.log person okay so we'll
go back here and reload and now you can
see it gives us a string that is
formatted correctly it has quotes around
the keys and around the string but not
around the number okay so that's valid
Jason.

output:

{"name":"Brad","age":35}

 we could send to a server now if
you want to take this JSON string and
turn it back to an object that's easy as
well and you would do that because if we
try to do person dot name 

console.log(person.name);

var person = {
		"name" : "Brad",
		"age" : 35,
		
	}

	person = JSON.stringify(person);
	console.log(person.name);

output: //undefined

and reload
we're going to get undefined okay.

 so what we want to do is parse it back into an object so for that we would use Jason
dot parse okay and we'll pass in person
and now if we reload we're able to get
Brad okay it's back to an object all
right so I'm just going to comment these
out here and then I'm going to add some
more stuff to this so let's say we want
address and we'll set that to an object
which will have a streak
se5 main street which isn't my real
address by the way and then city will
say Boston alright 


var person = {
	"name" : "Brad",
	"age" : 35,
	
}

person = JSON.stringify(person);

person = JSON.parse(person);
console.log(person.name);

now lets comment these out and lets add more stuff to this person object.

var person = {
	"name" : "Brad",
	"age" : 35,
	address: {
		street: "5 main st",
		city: "Boston"
	},
	children: ["Brianna","Nicholas"]
	
}

console.log(person.address.street);

//output: 5 main st

Now lets say we want to access Brianna

console.log(person.children[0]);

Now lets create an array of objects:

var people = [
	{
		name: "Brad",
		age: 35
	}, 
	{
		name: "John",
		age: 40
	},
	{
		name: 'Sara',
		age:34
	}
]
//Now print John

console.log(people[1].age);


4. For Of loop:
https://www.youtube.com/watch?v=Y8sMnRQYr3c

	for(let i=0;i<bubbles.length;i++){
		bubble[i].move();
		bubble[i].show();
	}>

let me count through the whole array to act on everything in the array. and this can happen with arrays of objects.  it can happen with arrays of numbers. let me double all the numbers in the array or let me add up all the numbers in the array. 

there are actually other ways of doing that too. 

For every bubble in the bubbles array,  bubble[i] means every element of the bubbles.

So i can actually do the exact same loop. 

for(let bubble of bubbles){
	bubble.move();
	bubble.show();

}

so these two loops means exactly the same. the first is the counting with the index to address every element in the array and moving and showing them. 

the second is just saying hey javascript, i dont feel like counting today. could you take care of this for me. just give me every single bubble in order in the array bubbles, and move and show them. later i will show you how to delete things in array. then those are the cases where i really need the counter. counter plays a role. but if the counter doesnt play a role, it just wants to do something to every element, then this is what i should do.

for of loop

const bubbles=[1,2,3,4,5];
for(let bubble of bubbles) {
console.log(bubble * 2)
}


5. For In Loop

when dealing with objects in this example here:

var monsters = {'Canada':'Sass','Nepal':'Yeti','Scotland':'Loch'}

because it is an object, there is no length property. So if do
console.log(monsters.length); //it gives me undefined.

so i cant use the for loop because i dont know how many items are in there. and thats because of the 
way objects are put together. you can put different things in there, you can have more than just strings or numbers and booleans. so, it doesnt have a length property. so how do we do this. how do we loop through everything in that object without knowing how many things there are in the object. 

there is another type of loop called for in loop that allows us to do this:

we can say for something in something else.

for(var in obj) {}

for variable in an object. this is the way we are going to write this. So i am going to declare a variable. let prop. it can be anything. it can be abcd. it doesnt matter. i am just going to call it prop. just so it makes sense, because i am going to be looking at the properties, that are inside of my object called monsters. 

eg. for(let prop in monsters){}

prop is like counter variable for my for loop. 

and if i run this, I get my loop:

Canada, Nepal, Scotland

Those are the properties. these are the names of the individual things. it is kind of like the keys: the index for each one of those things. 

remember we can do: console.log(monsters[prop]);

output: Sass, Yeti, Loch

now i cant do dot notation, because this is a variable that is holding those three values-one at a time as we go through the loop. it is not a string. these have different names. 

monsters is what i am looping through. it is saying hey just give me a list, i am gonna go once per property and do whatever i have got written inside here inside curly braces. If there are three things, i am gonna loop 3 times, if there are 40 things i am going to loop 40 times. 

so prop is the container, that is used temporarily to hold each of these things, as we go through monsters. 

So this is the for in loop. so when you are looking at an object instead of an array, you dont know how many items there are because there is no length property: so we use a for in loop. we still declare a variable: we initialise a variable to use as a counter through the loop. we just dont know how many items there are. this is the thing: monster that we wanted to loop through. 


Example:

var monsters = [{'Canada':'Sass','Nepal':'Yeti','Scotland':'Loch'},{'Canada':'Bass','Indonesia':'Yeti','Scotland':'Loch'}];

for(let prop in monsters){console.log(monsters[prop]);}


Now  we can use a for in loop for an array as well. 

var pets = ["Apple","Banana","Mango"];

with those 3 names, we wanted to loop through pets. 

for(let prop in pets) {
	console.log("In", prop, "we have the ", pets[prop]);
}

output: In 0 we have Apple.

so we can use for in loop for an array. prop just becomes the index. pets is the array we are looping through. and thats the for in loop.


Difference between ForEach and Map

https://codeburst.io/javascript-map-vs-foreach-f38111822c0f

Key Takeaways
Just about anything you can do with forEach() you can do with map(), and vise versa.
map() allocates memory and stores return values. forEach() throws away return values and always returns undefined.
forEach() will allow a callback function to mutate the current array. map() will instead return a new array.

Filter:

https://www.youtube.com/watch?v=rRgD1yVwIvE&t=5s

const ages = [33,12,20,16,5,54,21,44,61,13,45,25,64,32];

we want all the ages that are 21 and over.

let canDrink = [];

for(let i=0;i<ages.length;i++) {
	if(ages[i] >=21) {
		canDrink.push(ages[i])
	}
}

ages.filter((age)=>{
	return age >=21
})

console.log(canDrink);

so thats how we would do with the for loop.

but lets see how we can do with filter.

with filter all we have to do is define a variable, again we will call it canDrink.

const canDrink = ages.filter();

filter takes in a function just like the for each did. and we can also get the index and stuff like that if we want.

const canDrink = ages.filter(age=>age>=21);
console.log(canDrink);

so we went from ugly piece of code to this nice elegant oneliner. 

const reatilCompanies = companies.filter(company=>{
	if(company.category ==='Retail') {
		return true;
	}
})

console.log(retailCompanies);

so we will have 3 companies with the retail category. 

using one liner

const retailCompanies = companies.filter(company => company.category==='Retail');

console.log(retailCompanies);


const lastedTenYears = companies.filter(company => (company.end - company.start >=10))



let vals  = [5,4,9,2,1];

let hello = vals.filter(x=> x % 2 == 0);




console.log(hello);

Filter is another higher order function with javascript arrays. Higher order function means it expects as an argument some function. the argument function which receives as an argument itself an element of the array. and, based on the element it should return true or false. if you want to keep it, it returns true and false if you dont want to keep it. 


Object.keys

we are going to talk about 3 separate methods that belong to objects: keys, values and entries. these 3 methods let u turn an object into an iterable object. 

so what is an iterable object?

well, array is an iterable object. it is probably the most common. it is something that you can easily step through something very common. 

with the object, i have a bunch of properties. but there is no way for me to know which one is first, which one is second and which one is third and so on. there is no index that says these are supposed to go on a certain order. and there is no length property. i cannot ask what is the length of this object.

let names={
	name1: 'Anushree',
	name2:'Shreela',
	name3:'Sarita'
}

so an iterable object for example an array. strings are also iterables, node lists are iterables. typed arrays, map sets and the arguments key that you get inside of a function. Those are all iterable objects and those are all things that you can ask for the length and we can use a for in loop. or we can use a for of loop as well. for of loops are designed to work with iterable objects. so you have got your property name, the variable name that you are going to declare to use as you go through it. and, then the thing that you are going to loop through. 

for(let prop of arr){}

so arr would be your iterable objects here. and prop would represent each one of the elements. 	so this the reason you would want to have iterable. other reasons for having iterable objects like arrays. It means we can do things like call
foreach() method. there is foreach method on arrays as well as on node lists. so this lets us call a function once for each of the elements. Inside there i cant do that on an object.theres also the other array methods: filter() and map()
and reduce(). These are very common, very useful methods that belong to array objects.

Now these three methods:
Object.keys(obj)
Object.values(obj)
Object.entries(obj)

will create an array from an object. So then we can use the

for of loop
forEach() loop
filter()
map()
and reduce()

So, how do we use these methods?
let keys = Object.keys(names);
let values = Object.values(names);
let entries = Object.entries(names);

output of Entries:
[
	['name1':'Anu'],
	['name2':'Shreela'],
	['name3:'Babita']

]

For every one of the items inside this array, there is going to be two properties. property0 and property1. property0 will be the key. property1 will be the value. we dont need to know what the names are 
So these methods: Keys, values and entries:
it allows to turn the object into something called iterable. so you can use it with all the functionality that comes with javascript dealing with iterables and probably the most useful thing that you are going to find in practical terms will be the ability that you can now use these 4 methods on whatever came back from whichever the three methods that you were using. 


 let columns= [
      {
        "header": "Current",
        "field": "FieldOne",       
        "children": [
        	 {"header": "wala",
           "field": "FieldOne" 
           },
           {"header": "America",
           "field": "FieldTwo" 
           }
        ]
      }
]

columns.map(eachColumn=>{
	return (
  
    eachColumn.children.map(child=>{
    	console.log(child)
    })
  )
})

{header: "wala", field: "FieldOne"}
(index):51 {header: "America", field: "FieldTwo"}


The reduce method receives two arguments, passed in automatically by javascript: the previous value and the current value. the reduce method not only accepts the callback but it also accepts the initial value, lets say an empty array. so the initial value of the reduced value. 

now ofcourse you want to adjust this reduced value by returning something. it will then loop through all the elements and simply add them to the initial values step by step. So here i want to return the updated values starting with the initial one is then stored dynamically in this first argument which is received in each loop. 


.reduce((arr,el)=>{
	return arr.concat(el)
},[])

If you dont provide the initial value to the accumulator, by default, the initial value will be the first thing in the array. 

let vals = [5,4,1,2,9];

const sum = vals.reduce((prev,next)=>{
	prev + next;
})

console.log(sum);




Find Method:

The Array.find() is an inbuilt function in JavaScript which is used to get the value of the first element in the array that satisfies the provided condition.It checks all the elements of the array and whichever the first element satisfies the condition is going to print. 

var array1 = [5, 12, 8, 130, 44];

var found = array1.find(function(element) {
  return element > 10;
});



console.log(found);

6. JSON.stringify

why use JSON.stingify

A common use of JSON is to exchange data to/from a web server. When sending data to a web server, the data has to be a string. Convert a JavaScript object ...

var myJSON = JSON.stringify(obj);

myJSON is now a string, and ready to be sent to a server:

const blankCurrencyInfo = {
    code: '',
    label: '',
    symbol: '',
    description: '',
    exponent: '',
    iri: '',
    shortName: ''
}

var myJSON =. JSON.stringify(blankCurrencyInfo);
console.log(myJSON);

{"code":"","label":"","symbol":"","description":"","exponent":"","iri":"","shortName":""}


7. Reduce Method

The reduce () method reduces the array to a single value. That single value can be a number, a string, object or anything.  The reduce() method executes a provided function for each value of the array (from left-to-right). The return value of the function is stored in an accumulator (result/total).

The reduce() method takes a callback function with mainly 2 parameters: the accumulator and the currentValue.

const numbers = [1,-1,2,3];


let sum = 0;

for(let n of numbers) {
	sum +=n;
}
console.log(sum);

This accumulator parameter here is exactly like the sum we have here. it is something that we initialise, and this callback fucntion is executed multiple times. each time the currentValue will be set to one element in this array. so in each call we want to set this currentValue and add it to accumulator. So we simply return the sum of accumulator and currentValue.

numbers.reduce((accumulator,currentValue)=>{
	return accumulator + currentValue;
})

Internally, the reduce method will the result and store it in the accumulator. you will see that in a second. Now, one last thing we need to do here is to initialise this accumulator to zero. 

numbers.reduce((accumulator, currentValue)=>{
	return accumulator + currentValue;
},0)



So as the second argument to the reduce method we pass 0. Note, that this reduce method has 2 arguments: The first argument is a callback function and the second argument is the initial value for the accumulator. just like let sum = 0;

Finally we get the result as a single value. In this case, sum. 

const numbers = [1,-1,2,3];
const sum = numbers.reduce((accumulator,currentValue)=>{
	return accumulator + currentValue;
},0)








 this method does not change the original array.



array.reduce(function(total, currentValue, currentIndex, arr), initialValue)

function(total,currentValue, index,arr)

Required. A function to be run for each element in the array.
Function arguments:

total	Required. The initialValue, or the previously returned value of the function
currentValue	Required. The value of the current element
currentIndex	Optional. The array index of the current element
arr	Optional. The array object the current element belongs to

In this example, we want to reduce all these elements in the array into a single number.

const numbers = [-1,1,2,3,4];

Another example of reduce function:


let someOrder = {
	items: [
  	{name:'Dragon Food', price: 8, quantity: 8},
    {name:'Dragon Cage', price: 800, quantity: 2}
  ]
}
const orderTotal = someOrder.items.reduce((prev,cur)=>prev + (cur.price * cur.quantity), 0);
console.log('order Total is', orderTotal);


let vals  = [5,4,9,2,1];

let biggest = vals.reduce((prev,cur)=>cur > prev ? cur : prev);
console.log(biggest);











8. export default considered Harmful
'

Unconcious Incompetence

Uncouncious means 

9. Dot Notation vs Bracket Notation
https://codeburst.io/javascript-quickie-dot-notation-vs-bracket-notation-333641c0f781

Dot Notation:

let obj = {
  cat: 'meow',
  dog: 'woof'
};
let sound = obj.cat;
console.log(sound);
// meow

Bracket Notation:

let obj = {
  cat: 'meow',
  dog: 'woof'
};
let sound = obj['cat'];
console.log(sound);
// meow

You can access properties on an object by specifying the name of the object followed by the property name in brackets. Hereâs the syntax: objectName["propertyName"].

When working with bracket notation, property identifiers only have to be a String. They can include any characters, including spaces. Variables may also be used as long as the variable resolves to a String.

NOTE: VARIABLES MAY ALSO BE USED AS LONG AS TEH VARIABLE RESOLVES TO A STRING

This means there are fewer limitations when working with bracket notation. We can now have spaces in our strings, and can even start strings with numbers.

Perhaps most importantly, we can now use variables to access properties in an object. Itâs important the variable you are using references a String.

let obj = {
  cat: 'meow',
  dog: 'woof'
};
let dog = 'cat';
let sound = obj[dog];
console.log(sound);
// meow

The above example is similar to a previous example weâve already seen. The main difference is weâre now using bracket notation to pass in a variable. Be careful, it may look like we are looking for the dog property in our obj, but thatâs not entire correct. dog is a variable with a value of 'cat'. Since weâre using brackets, the string value is passed in and we search for the 'cat' property â obj["cat"]. Thus, meow is logged to the console.

when using dot notation:

Property identifiers cannot contain variables.

Property identifiers have to be a String or a variable that references a String.


const mockData = [
  {
    mainChartData: {
      value1: 43,
      value2: 13,
      value3: 25,
      value4: 50,
    },
    styles: {
      width: 120,
      columnWidth: 2,
      innerSize: 110,
      colors: ["#9B59B6", "#FFC627", "#EE3124", "#00BFBF"]
    }
  },
  {
    mainChartData: {
      value1: 5,
      value2: 5,
      value3: 5,
      value4: 5,
    },
    styles: {
      width: 120,
      columnWidth: 2,
      innerSize: 110,
      colors: ["#9B59B6", "#FFC627", "#EE3124", "#00BFBF"]
    }
  }
 ]
 
calculateTotal = mainData => {
   return Object.keys(mainData).reduce((accumulator,currentValue)=>{
   	return accumulator+ mainData[currentValue];
   },0)
}
 
data.reduce((accumulator,currentValue)=>{
	const total = calculateTotal(currentValue.mainChartData);
  console.log('total is', total);
})

Arrow function solves a lot of issues you often had with the this keyword. when you use this inside the arrow function, it will always keep its context 
and not change it surprisingly on runtime.


10. Truthy 
https://developer.mozilla.org/en-US/docs/Glossary/Truthy

In JavaScript, a truthy value is a value that is considered true when encountered in a Boolean context. All values are truthy unless they are defined as falsy (i.e., except for false, 0, 0n, "", null, undefined, and NaN).

https://www.sitepoint.com/javascript-truthy-falsy/

The following values are always falsy:

false
0 (zero)
'' or "" (empty string)
null
undefined
NaN

Everything else is truthy. That includes:

'0' (a string containing a single zero)
'false' (a string containing the text âfalseâ)
[] (an empty array)
{} (an empty object)
function(){} (an âemptyâ function)
































































































































































